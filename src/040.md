# Tip #Handle errors while using defer to prevent silent failures

> 原始链接：[Golang Tip #40: Handle errors while using defer to prevent silent failures](https://twitter.com/func25/status/1764997813501608144)

There's a subtle trap that many fall into: forgetting to check for errors in deferred calls.
![](./images/040/1.png)

Let's use the snippet above as an example.

If the file closure operation fails (perhaps due to an un-flushed write operation or an issue with the file system) and this error is not checked, we lose the opportunity to handle the failure gracefully.

Now, still using defer, we have 3 options:

- Handle this as a function error
- Panic
- Logging

Panic or logging are straightforward, but how to handle this as a function error?

In this case, the solution might be easy with named returns:
![](./images/040/2.png)

Or... maybe shorter:
![](./images/040/3.png)

However, this approach remains somewhat lengthy due to the need to create an anonymous function, which increases nesting.

Considering that most deferred calls involve closing resources, such as connections or I/O operations, we can simplify this with a more concise, one-liner solution with io.Closer:
![](./images/040/4.png)

But this will cause a panic because of dereferencing err while err can be nil, right?

Actually not, this code works well.

(long story alert)

Fortunately, since error is an interface, a nil error doesn't mean it's a nil pointer in the same sense as a nil pointer for other pointer types (like \*int).

A nil (interface) error has {type = nil; value = nil}, but it's still... a value, the zero value of the interface.

When we take the address of err using &err in the defer closeWithError(&err, file) call, we're not getting a nil pointer. We're getting a pointer to an interface variable that is {type = nil, value = nil}.

So in the closeWithError function, when we dereference the error pointer with \*err to assign a new value, we're not dereferencing a nil pointer (which would cause a panic).

Instead, we're modifying the value of an interface variable through its pointer.
